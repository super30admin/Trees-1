// Time Complexity: O(n)
// Space Complexity: O(n + h) -> O(n)
public class BtPreInorder {
    HashMap<Integer, Integer> map;
    int idx;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder == null || inorder == null || preorder.length == 0) // atleast root should be given
            return null;
        
        // location of first root
        idx = 0 ;

        map = new HashMap<>();
        // find the index of roots in inorder
        for(int i = 0 ; i < inorder.length ; i ++)
        {
            map.put(inorder[i], i);
        }
        return builder(preorder, 0,  preorder.length -1);
    }
    
    private TreeNode builder(int [] preorder, int start, int end)
    {
        // base
        if(start > end)
            return null;
        
        // logic
        TreeNode root = new TreeNode(preorder[idx]);
        // next root
        idx++;
        int rootIdx = map.get(root.val);
        root.left = builder(preorder, start, rootIdx-1);
        root.right = builder(preorder, rootIdx+1, end);
        return root;
    }
}

// Time Complexity: O(n^2)
// Space Complexity: O(n^2)
public class BtPreInorder {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder == null || inorder == null || preorder.length == 0) // atleast root should be given
            return null;
        
        TreeNode root = new TreeNode(preorder[0]);
        int rootIdx = -1;
        
        // find the index of root in inorder
        for(int i = 0 ; i < inorder.length ; i ++) // O(n)
        {
            if(root.val == inorder[i])
            {
                rootIdx = i;
                break;
            }
        }
        
        //O(n)
        int [] inorderLeft = Arrays.copyOfRange(inorder, 0, rootIdx);
        int [] inorderRight = Arrays.copyOfRange(inorder, rootIdx+1, inorder.length);
          
        // O(n)
        int [] preorderLeft = Arrays.copyOfRange(preorder, 1, rootIdx + 1);
        int [] preorderRight = Arrays.copyOfRange(preorder, rootIdx+1, preorder.length);
        

        root.left = buildTree(preorderLeft, inorderLeft);
        root.right = buildTree(preorderRight, inorderRight);
        
        return root;
    }
}







































































































































































































































































































































































































































































































































































































































































































public class BtPreInorder {
    
}
